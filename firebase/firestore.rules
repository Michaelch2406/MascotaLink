rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Función para verificar que el usuario es dueño del documento
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Regla para la colección principal de usuarios
    match /usuarios/{userId} {
      allow read: if request.auth != null;
      allow write: if isOwner(userId) &&
                     (resource == null || (
                        request.resource.data.rol == resource.data.rol &&
                        request.resource.data.cedula == resource.data.cedula
                     ));
      allow delete: if false;
    }

    // Colecciones de perfiles: duenos y paseadores
    match /duenos/{userId} {
      allow read: if request.auth != null;
      allow write: if isOwner(userId);
      allow delete: if false;
    }

    match /paseadores/{userId} {
      allow read: if request.auth != null;
      allow write: if isOwner(userId);
      allow delete: if false;
    }

    // Colección denormalizada para búsqueda
    match /paseadores_search/{paseadorId} {
      allow read: if request.auth != null;
      allow write: if false; // Solo las Cloud Functions pueden escribir aquí
    }

    // Colección de pagos con acceso restringido al pagador.
    match /pagos/{pagoId} {
      allow read: if request.auth != null &&
                  resource.data.id_usuario == request.auth.uid;
      allow create: if request.auth != null &&
                     request.resource.data.id_usuario == request.auth.uid &&
                     request.resource.data.monto is number &&
                     request.resource.data.monto > 0 &&
                     request.resource.data.estado in ['PROCESSING', 'COMPLETED'];
      allow update, delete: if false;
    }

    // Reglas adicionales
    function isReservaParticipant(res) {
      return request.auth != null &&
             (request.auth.uid == res.data.id_dueno ||
              request.auth.uid == res.data.id_paseador);
    }

    function reservaStateTransitionAllowed(prev, next) {
      return prev == next ||
             (prev == "PENDIENTE_ACEPTACION" && next in ["ACEPTADO", "RECHAZADO", "CANCELADO"]) ||
             (prev == "ACEPTADO" && next in ["CONFIRMADO", "CANCELADO"]) ||
             (prev == "CONFIRMADO" && next in ["EN_CURSO", "COMPLETADO", "CANCELADO"]) ||
             (prev == "EN_CURSO" && next in ["COMPLETADO", "CANCELADO"]) ||
             (prev == "COMPLETADO" && next == "COMPLETADO") ||
             (prev == "RECHAZADO" && next == "RECHAZADO") ||
             (prev == "CANCELADO" && next == "CANCELADO");
    }

    // Colección para manejar las solicitudes de reseteo de contraseña.
    // NADIE desde el cliente puede leer o escribir aquí. Solo el backend (Admin SDK) tiene acceso.
    match /solicitudes_recuperacion/{solicitudId} {
      allow read, write: if false;
    }

    // Subcolecciones bajo usuarios
    match /usuarios/{userId}/metodos_pago/{metodoId} {
      allow read: if isOwner(userId);
      allow create, update: if isOwner(userId) &&
                            request.resource.data.banco is string &&
                            request.resource.data.numero_cuenta is string &&
                            request.resource.data.numero_cuenta.size() >= 4 &&
                            request.resource.data.predeterminado in [true, false];
      allow delete: if false;
    }

    // Subcolección para los paseadores favoritos de un dueño
    match /usuarios/{userId}/favoritos/{paseadorId} {
      allow read, write, delete: if isOwner(userId);
    }

    // Subcolección de mascotas bajo usuarios (para dueños)
    match /usuarios/{userId}/mascotas/{mascotaId} {
      allow read, write: if isOwner(userId);
    }

    // Mascotas dentro de duenos
    match /duenos/{duenoId}/mascotas/{mascotaId} {
      allow read: if request.auth != null;
      allow write: if isOwner(duenoId);
    }

    // Subcolecciones bajo paseadores
    match /paseadores/{userId}/disponibilidad/{disponibilidadId} {
      allow read: if request.auth != null;
      allow write: if isOwner(userId);
    }

    match /paseadores/{userId}/zonas_servicio/{zonaId} {
      allow read: if request.auth != null;
      allow write: if isOwner(userId);
    }

    // Regla para permitir la lectura de la colección group 'zonas_servicio'
    match /{path=**}/zonas_servicio/{zonaId} {
      allow read: if request.auth != null;
    }

    // Reseñas
    match /resenas/{resenaId} {
      allow read: if request.auth != null;
      // La escritura se podría limitar a un dueño que haya completado un servicio con el paseador
      allow write: if false;
    }

    // Servicios
    match /servicios/{servicioId} {
      // Solo el dueño o el paseador pueden leer un servicio específico.
      // La regla de listado (query) se debe manejar a nivel de la app.
      allow read: if resource != null && request.auth != null &&
                  (request.auth.uid == resource.data.due_id || request.auth.uid == resource.data.pas_id);

      // El dueño crea el servicio.
      allow create: if request.auth != null &&
                    request.auth.uid == request.resource.data.due_id;

      // Dueño y paseador pueden actualizar estados específicos.
      allow update: if resource != null && request.auth != null && (
        (request.auth.uid == resource.data.due_id && request.resource.data.estado in ['SOLICITADO', 'CANCELADO', 'COMPLETADO']) ||
        (request.auth.uid == resource.data.pas_id && request.resource.data.estado in ['CONFIRMADO', 'EN_PROGRESO'])
      );

      allow delete: if false;
    }

    // Reservas
    match /reservas/{reservaId} {
      // El usuario puede crear una reserva si el campo 'id_dueno' apunta a su propio documento de usuario
      // y el estado inicial es PENDIENTE_PAGO.
      allow create: if request.auth != null &&
                    request.resource.data.id_dueno == /databases/$(database)/documents/usuarios/$(request.auth.uid) &&
                    request.resource.data.estado == "PENDIENTE_ACEPTACION";

      // Lectura autorizada para dueño y paseador.
      allow read: if request.auth != null &&
                  resource != null &&
                  (resource.data.id_dueno == /databases/$(database)/documents/usuarios/$(request.auth.uid) ||
                   resource.data.id_paseador == /databases/$(database)/documents/usuarios/$(request.auth.uid));

      allow update: if (
        // Reglas para el Paseador
        (/databases/$(database)/documents/usuarios/$(request.auth.uid) == resource.data.id_paseador &&
          (
            // Caso 1: Aceptar solicitud
            (
              request.resource.data.estado == 'ACEPTADO' &&
              resource.data.estado == 'PENDIENTE_ACEPTACION' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(['estado', 'fecha_respuesta'])
            ) ||
            // Caso 2: Rechazar solicitud
            (
              request.resource.data.estado == 'RECHAZADO' &&
              resource.data.estado == 'PENDIENTE_ACEPTACION' &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(['estado', 'fecha_respuesta', 'motivo_rechazo'])
            ) ||
            // Caso 3: Iniciar/Completar paseo
            (
              request.resource.data.estado in ['EN_CURSO', 'COMPLETADO'] &&
              resource.data.estado in ['CONFIRMADO', 'EN_CURSO'] &&
              request.resource.data.diff(resource.data).affectedKeys().hasOnly(['estado'])
            )
          )
        ) ||
        // Reglas para el Dueño
        (/databases/$(database)/documents/usuarios/$(request.auth.uid) == resource.data.id_dueno &&
          request.resource.data.estado == 'CANCELADO' &&
          resource.data.estado in ['PENDIENTE_ACEPTACION', 'ACEPTADO', 'CONFIRMADO'] &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['estado']))
      );

      allow delete: if false;
    }

    // Chats y mensajes
    match /chats/{chatId} {
      // Un participante puede leer o actualizar un chat.
      allow read, update: if resource != null && request.auth != null &&
                         request.auth.uid in resource.data.participantes_ids;

      // Un usuario puede crear un chat si es uno de los participantes.
      allow create: if request.auth != null &&
                      request.auth.uid in request.resource.data.participantes_ids;

      match /messages/{messageId} {
        // Para leer/actualizar un mensaje, el usuario debe estar en la lista de participantes del chat padre.
        allow read, update: if request.auth != null &&
                           request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantes_ids;

        // Para crear un mensaje, el usuario debe ser el sender y estar en la lista de participantes del chat padre.
        allow create: if request.auth != null &&
                        request.auth.uid == request.resource.data.sender_id &&
                        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantes_ids;
      }
    }
  }
}
